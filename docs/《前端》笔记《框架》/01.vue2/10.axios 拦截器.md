---
title: axios 拦截器
date: 2022-06-27 11:01:39
permalink: /pages/36b5ae/
categories:
  - 《前端》笔记《框架》
  - 1.vue2
tags:
  - 
---
**特性：** 在每次发起 ajax 请求 和得到 响应 的时候自动被触发

## 创建 axios 实例
  ```js
  import axios from 'axios'

  const service = service.create()
  ```

## 请求 拦截器：
  **语法翻译：** 服务.拦截器s.请求.使用().请求

  ```js
  service.interceptors.request.use(request => {
    // 参数一：成功的回调（请求对象）
    // 参数二：失败的回调（错误对象）
  }
  ```

## 响应 拦截器：
  **语法翻译：** 服务.拦截器s.响应.使用().响应

  ```js
  service.interceptors.response.use(response => {
    // 参数一：成功的回调（响应对象）
    // 参数二：失败的回调（错误对象）
  })
  ```

## 使用场景
  ### 相同的 使用场景
  #### （一）抛出失败
  ```js
  // 请求拦截器
  service.interceptors.request.use(config => {}, error => {
    return Promise.reject(error)
  })
  ```

  ```js
  // 响应拦截器
  service.interceptors.response.use(response => {}, error => {
    Message.error(error)

    // 抛出错误。只会进入 .catch() 不会进入 .then()
    return Promise.reject(error)
  })
  ```

  #### （二）Loading 效果
  **原理：** 借助于 element ui 提供的 Loading 效果组件（https://element.eleme.cn/#/zh-CN/component/loading）

  ```js
  import { Loading } from 'element-ui'
  
  let loadingInstance = null  // 存储 Loading 组件的实例对象

  service.interceptors.request.use(confin => {  // 请求拦截器
    loadingInstance = Loading.service({ fullscreen: true }) // 创建 Loading 组件的实例，并全屏展示 Loading 效果
    return config
  })

  service.interceptors.response.use(response => {  // 响应拦截器
    loadingInstance.close() // 关闭 Loading 效果
    return response
  })
  ```

  ### 请求拦截器 的使用场景
  #### （一）携带 token
  **原理：** 在参数一，也就是请求对象身上添加 属性

  ```js
  service.interceptors.request.use(config => {
    if (store.getters.token) {
      config.headers['Authorization'] = `Bearer ${store.getters.token}`
    }
  })
  ```

  #### （二）请求参数格式的处理。如：将 json 的参数格式改为 x-www-form-urlencoded
  ```js
  // 请求拦截器
  service.interceptors.request.use(config => {
    /*
      BUG：请求参数格式和服务端参数格式不一致，导致传递的参数无效

      解决原理：将请求参数转换成字符串格式。因为 content-type 会根据请求参数的格式自动变换请求格式
      - application/x-www-form-urlencoded 格式：categoryId=263919
      - application/json                  格式：{"categoryId": 263919}

      解决方法：
      - new URLSearchParams(data)：定义了很多处理 URL 的参数的方法
      - URLSearchParams 对象.toString()：将参数转换成字符串
    */
    if (config.data) {
      config.data = new URLSearchParams(data).toString()
    }
  })
  ```

  ### 响应拦截器 的使用场景
  #### （一）去除多余的响应信息，只返回需要的 data 数据
  **原理：** 判断参数一，就是响应对象中的状态码，如果为 200 就 return 需要的 data 数据

  ```js
  service.interceptors.response.use(response => {
    // 返回响应结果
    if (response.data.code === 0) {
      return response.data.data
    } else {
      Message.error(response.data.msg)

      // 把异步 API 执行失败的结果传递出去
      return Promise.reject(response.data.msg)
    }
  })
  ```

  ### （二）判断 token 是否过期
  **原理：** 在响应拦截器中判断后端响应的状态码，如果是 401 则表示 token 过期，然后清空 token、和 vuex 中的 token 即可

  ```js
  service.interceptors.response.use(response => {
  }, error => {
    if (error.response.status === 401) { // 判断 token 是否过期
      Message.warning('token 过期，请重新登录')
      store.commit('user/setToken', '')
    }
    return Promise.reject(error)
  })
  ```